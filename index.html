<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Sky Catch Challenge</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (UMD for browser) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel Standalone (to compile JSX/TS in browser) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      /* Prevent pull-to-refresh on mobile */
      body {
        overscroll-behavior-y: contain;
        touch-action: none;
      }
      /* Ensure full height for the app container */
      html, body, #root {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
</head>
  <body class="bg-slate-900 text-white overflow-hidden">
    <div id="root"></div>

    <!-- Main Application Code -->
    <script type="text/babel" data-presets="react,typescript">
      const { useState, useEffect, useRef, useCallback } = React;

      // --- constants.ts ---
      const GAME_DURATION = 30; // seconds
      const WINNING_SCORE = 200;
      const COUPON_VALUE = 50;

      const CANVAS_WIDTH = 480; // Logical width
      const CANVAS_HEIGHT = 800; // Logical height

      const PLAYER_WIDTH = 80;
      const PLAYER_HEIGHT = 60;
      const PLAYER_Y_OFFSET = 100; // Distance from bottom

      const ITEM_SIZE = 40;
      const BULLET_SIZE = 10;
      const BULLET_SPEED = 12;

      const SCORE_MAP = {
        FOOD_BURGER: 20,
        FOOD_PIZZA: 20,
        ENEMY_X: -5,
        ENEMY_SKULL: -10,
      };

      // --- types.ts (Simulated for JS runtime) ---
      const GameScreen = {
        HOME: 'HOME',
        PLAYING: 'PLAYING',
        RESULT: 'RESULT',
      };

      const ItemType = {
        FOOD_BURGER: 'FOOD_BURGER',
        FOOD_PIZZA: 'FOOD_PIZZA',
        ENEMY_X: 'ENEMY_X',
        ENEMY_SKULL: 'ENEMY_SKULL',
      };

      // --- components/Button.tsx ---
      const Button = ({ onClick, children, className = '', variant = 'primary' }) => {
        const baseStyle = "px-8 py-3 rounded-full font-bold text-lg transition-transform active:scale-95 shadow-lg select-none";
        
        const variants = {
          primary: "bg-gradient-to-r from-yellow-400 to-orange-500 text-white hover:from-yellow-500 hover:to-orange-600 border-2 border-orange-300",
          secondary: "bg-white text-slate-800 hover:bg-gray-100 border-2 border-slate-200",
          danger: "bg-red-500 text-white hover:bg-red-600 border-2 border-red-400",
        };

        return (
          <button 
            onClick={onClick} 
            className={`${baseStyle} ${variants[variant]} ${className}`}
          >
            {children}
          </button>
        );
      };

      // --- components/Home.tsx ---
      const Home = ({ onStart }) => {
        return (
          <div className="flex flex-col items-center justify-center h-full w-full p-6 bg-gradient-to-b from-sky-400 to-blue-600 text-center space-y-6">
            <div className="space-y-2">
              <h1 className="text-4xl font-extrabold text-white drop-shadow-md">
                æ¥ä½ç¾å‘³
                <br />
                <span className="text-yellow-300">å¤§ä½œæˆ°</span>
              </h1>
              <p className="text-blue-100 text-sm">Challenge for Coupon!</p>
            </div>

            <div className="bg-white/10 backdrop-blur-md rounded-2xl p-6 border border-white/20 w-full max-w-sm">
              <h2 className="text-xl font-bold mb-4 text-yellow-200">ğŸ® éŠæˆ²ç©æ³•</h2>
              <ul className="text-left space-y-3 text-white/90 text-sm leading-relaxed">
                <li className="flex items-start">
                  <span className="mr-2 text-lg">ğŸ‘</span>
                  <span>å·¦å³ç§»å‹•é›™æ‰‹ï¼Œæ¥ä½ç¾é£Ÿï¼</span>
                </li>
                <li className="flex items-start">
                  <span className="mr-2 text-lg">ğŸ”</span>
                  <span>æ¥ä½ç¾å‘³é£Ÿç‰© <b>+20åˆ†</b></span>
                </li>
                <li className="flex items-start">
                  <span className="mr-2 text-lg">ğŸ˜ˆ</span>
                  <span>å°å¿ƒæƒ¡é­”ä¸Ÿä¸‹çš„é™·é˜±ï¼</span>
                </li>
                <li className="flex items-start">
                  <span className="mr-2 text-lg">âŒ</span>
                  <span>æ¥åˆ° X æ‰£ <b>5åˆ†</b>ï¼Œéª·é«é ­ æ‰£ <b>10åˆ†</b></span>
                </li>
                <li className="flex items-start">
                  <span className="mr-2 text-lg">ğŸ”«</span>
                  <span><b>é»æ“Šç•«é¢</b>ç™¼å°„å­å½ˆæ¶ˆé™¤å£æ±è¥¿ï¼</span>
                </li>
              </ul>
            </div>

            <div className="bg-yellow-400/20 rounded-xl p-4 border border-yellow-400/50 animate-pulse">
              <p className="font-bold text-yellow-100">
                ğŸ† æŒ‘æˆ°ç›®æ¨™ï¼šè¶…é {WINNING_SCORE} åˆ†
              </p>
              <p className="text-yellow-300 font-extrabold text-xl">
                ç²å¾— {COUPON_VALUE} å…ƒæŠ˜åƒ¹åˆ¸ï¼
              </p>
            </div>

            <Button onClick={onStart} className="w-full max-w-xs shadow-xl shadow-blue-900/20">
              é–‹å§‹éŠæˆ² (30ç§’)
            </Button>
          </div>
        );
      };

      // --- components/Result.tsx ---
      const Result = ({ score, onRestart }) => {
        const isWinner = score >= WINNING_SCORE;

        return (
          <div className="flex flex-col items-center justify-center h-full w-full p-6 bg-gradient-to-b from-indigo-500 to-purple-800 text-center space-y-8">
            
            <div className="space-y-2">
              <h2 className="text-3xl font-bold text-white">éŠæˆ²çµæŸ</h2>
              <div className="text-6xl font-black text-white drop-shadow-lg">
                {score} <span className="text-2xl font-medium">åˆ†</span>
              </div>
            </div>

            {isWinner ? (
              <div className="bg-yellow-500 text-white p-6 rounded-2xl shadow-xl transform rotate-1 border-4 border-yellow-300 w-full max-w-xs relative overflow-hidden">
                <div className="absolute top-0 left-0 w-full h-full bg-white opacity-10 rotate-45 transform translate-y-10"></div>
                <h3 className="text-2xl font-bold mb-2">ğŸ‰ æ­å–œé”æˆï¼</h3>
                <p className="mb-4">ä½ å¤ªå²å®³äº†ï¼é€™æ˜¯ä½ çš„çå‹µ</p>
                <div className="bg-white text-slate-900 font-mono font-bold text-xl py-3 px-4 rounded-lg border-2 border-dashed border-slate-300">
                  ${COUPON_VALUE} æŠ˜åƒ¹åˆ¸
                </div>
                <p className="text-xs mt-2 opacity-80">*æˆªåœ–æ­¤ç•«é¢ä»¥å…Œæ›</p>
              </div>
            ) : (
              <div className="bg-white/10 backdrop-blur-md p-6 rounded-2xl border border-white/20 w-full max-w-xs">
                <div className="text-5xl mb-4">ğŸ’ª</div>
                <h3 className="text-xl font-bold text-white mb-2">å†æ¥å†å²ï¼</h3>
                <p className="text-indigo-200">
                  åªå·®ä¸€é»é»äº†ï¼<br/>
                  ç›®æ¨™æ˜¯ {WINNING_SCORE} åˆ†å–”ã€‚
                </p>
              </div>
            )}

            <Button onClick={onRestart} variant={isWinner ? 'secondary' : 'primary'} className="w-full max-w-xs">
              {isWinner ? 'å†ç©ä¸€æ¬¡' : 'ä¸æœè¼¸ï¼Œå†ç©ä¸€æ¬¡'}
            </Button>
          </div>
        );
      };

      // --- components/Game.tsx ---
      const Game = ({ onFinish }) => {
        const canvasRef = useRef(null);
        
        // Game State Refs (for Loop)
        const gameStateRef = useRef({
          score: 0,
          playerX: CANVAS_WIDTH / 2,
          items: [],
          bullets: [],
          lastTime: 0,
          lastUiSyncTime: 0,
          timeLeft: GAME_DURATION,
          isPlaying: true,
        });

        // Entities - Using a list to manage multiple spawners dynamically
        const spawnersRef = useRef([]);

        // React State for UI Overlay
        const [uiScore, setUiScore] = useState(0);
        const [uiTime, setUiTime] = useState(GAME_DURATION);

        // Initialize Spawners
        useEffect(() => {
          // Initial spawners: 1 Demon, 1 Chef
          spawnersRef.current = [
            { id: 'demon-1', x: 50, y: 60, direction: 1, type: 'DEMON', nextSpawnTime: 0 },
            { id: 'chef-1', x: CANVAS_WIDTH - 50, y: 60, direction: -1, type: 'CHEF', nextSpawnTime: 0 }
          ];
        }, []);

        // Helper: Spawn Item
        const spawnItem = (spawner) => {
          const isDemon = spawner.type === 'DEMON';
          let type;
          
          if (isDemon) {
            type = Math.random() > 0.6 ? ItemType.ENEMY_SKULL : ItemType.ENEMY_X;
          } else {
            type = Math.random() > 0.5 ? ItemType.FOOD_BURGER : ItemType.FOOD_PIZZA;
          }

          // Speed increases as time decreases
          const progress = 1 - (gameStateRef.current.timeLeft / GAME_DURATION);
          const itemSpeed = 3 + (progress * 4); // 3 to 7

          gameStateRef.current.items.push({
            id: Date.now() + Math.random(),
            x: spawner.x,
            y: spawner.y + 40,
            width: ITEM_SIZE,
            height: ITEM_SIZE,
            type,
            speed: itemSpeed,
            active: true,
          });
        };

        // Helper: Calculate next spawn time
        const getNextSpawnDelay = (timeLeft) => {
          const progress = 1 - (timeLeft / GAME_DURATION);
          const baseDelay = 1500 - (progress * 1100); 
          const jitter = Math.random() * 600;
          return baseDelay + jitter;
        };

        // Helper: Check Collision (Box)
        const isColliding = (rect1, rect2) => {
          return (
            rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y
          );
        };

        // Core Loop
        const gameLoop = useCallback((timestamp) => {
          if (!gameStateRef.current.isPlaying) return;
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          const state = gameStateRef.current;
          
          // Initialize timing
          if (state.lastTime === 0) {
            state.lastTime = timestamp;
            spawnersRef.current.forEach(s => {
              s.nextSpawnTime = timestamp + Math.random() * 1000;
            });
          }

          const deltaTime = timestamp - state.lastTime;
          state.lastTime = timestamp;

          // 1. Logic Update
          
          // Timer
          state.timeLeft -= deltaTime / 1000;
          if (state.timeLeft <= 0) {
            state.isPlaying = false;
            onFinish(state.score);
            return;
          }

          const elapsed = GAME_DURATION - state.timeLeft;

          // Dynamic Level Design
          if (elapsed > 10 && spawnersRef.current.filter(s => s.type === 'DEMON').length < 2) {
             spawnersRef.current.push({
               id: 'demon-2',
               x: CANVAS_WIDTH / 2,
               y: 60,
               direction: Math.random() > 0.5 ? 1 : -1,
               type: 'DEMON',
               nextSpawnTime: timestamp + 1000
             });
          }
          if (elapsed > 20 && spawnersRef.current.filter(s => s.type === 'DEMON').length < 3) {
             spawnersRef.current.push({
               id: 'demon-3',
               x: 40,
               y: 60,
               direction: 1,
               type: 'DEMON',
               nextSpawnTime: timestamp + 1000
             });
          }

          // Update Spawners
          spawnersRef.current.forEach(spawner => {
            spawner.x += spawner.direction * 2.5; 
            if (spawner.x < 40 || spawner.x > CANVAS_WIDTH - 40) {
              spawner.direction *= -1;
            }

            if (timestamp >= spawner.nextSpawnTime) {
              spawnItem(spawner);
              spawner.nextSpawnTime = timestamp + getNextSpawnDelay(state.timeLeft);
            }
          });

          // Update Items
          state.items.forEach(item => {
            item.y += item.speed;
            
            // Collision with Player
            const playerRect = {
              x: state.playerX - PLAYER_WIDTH / 2,
              y: CANVAS_HEIGHT - PLAYER_Y_OFFSET,
              width: PLAYER_WIDTH,
              height: PLAYER_HEIGHT
            };

            if (item.active && isColliding(item, playerRect)) {
              item.active = false;
              state.score += SCORE_MAP[item.type];
            }

            if (item.y > CANVAS_HEIGHT) item.active = false;
          });

          // Update Bullets
          state.bullets.forEach(bullet => {
            bullet.y -= bullet.speed;
            state.items.forEach(item => {
              if (item.active && bullet.active && isColliding(bullet, item)) {
                item.active = false;
                bullet.active = false;
              }
            });
            if (bullet.y < 0) bullet.active = false;
          });

          state.items = state.items.filter(i => i.active);
          state.bullets = state.bullets.filter(b => b.active);

          // 2. Render
          ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

          // Draw Spawners
          ctx.font = '40px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          spawnersRef.current.forEach(spawner => {
            const icon = spawner.type === 'DEMON' ? 'ğŸ˜ˆ' : 'ğŸ‘¨â€ğŸ³';
            ctx.fillText(icon, spawner.x, spawner.y);
          });

          // Draw Items
          state.items.forEach(item => {
            let icon = '';
            switch(item.type) {
              case ItemType.FOOD_BURGER: icon = 'ğŸ”'; break;
              case ItemType.FOOD_PIZZA: icon = 'ğŸ•'; break;
              case ItemType.ENEMY_X: icon = 'âŒ'; break;
              case ItemType.ENEMY_SKULL: icon = 'ğŸ’€'; break;
            }
            ctx.fillText(icon, item.x + item.width/2, item.y + item.height/2);
          });

          // Draw Bullets
          ctx.fillStyle = '#facc15'; 
          state.bullets.forEach(bullet => {
            ctx.beginPath();
            ctx.arc(bullet.x + bullet.width/2, bullet.y + bullet.height/2, BULLET_SIZE/2, 0, Math.PI * 2);
            ctx.fill();
          });

          // Draw Player
          ctx.font = '60px Arial';
          ctx.fillText('ğŸ‘', state.playerX, CANVAS_HEIGHT - PLAYER_Y_OFFSET + 30);

          // 3. Sync UI
          if (timestamp - state.lastUiSyncTime > 100) {
            setUiScore(state.score);
            setUiTime(Math.max(0, Math.ceil(state.timeLeft)));
            state.lastUiSyncTime = timestamp;
          }

          requestAnimationFrame(gameLoop);
        }, [onFinish]);

        // Input Handling
        const handleInput = useCallback((clientX) => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          
          const rect = canvas.getBoundingClientRect();
          const scaleX = CANVAS_WIDTH / rect.width;
          const canvasX = (clientX - rect.left) * scaleX;

          gameStateRef.current.playerX = Math.max(PLAYER_WIDTH/2, Math.min(CANVAS_WIDTH - PLAYER_WIDTH/2, canvasX));
        }, []);

        const handleShoot = useCallback(() => {
          if (!gameStateRef.current.isPlaying) return;
          
          gameStateRef.current.bullets.push({
            id: Date.now() + Math.random(),
            x: gameStateRef.current.playerX - BULLET_SIZE / 2,
            y: CANVAS_HEIGHT - PLAYER_Y_OFFSET,
            width: BULLET_SIZE,
            height: BULLET_SIZE,
            speed: BULLET_SPEED,
            active: true,
          });
        }, []);

        useEffect(() => {
          gameStateRef.current.lastTime = 0;
          gameStateRef.current.isPlaying = true;
          
          const animId = requestAnimationFrame(gameLoop);
          
          const onTouchMove = (e) => {
            e.preventDefault(); 
            handleInput(e.touches[0].clientX);
          };
          
          const onMouseMove = (e) => {
            handleInput(e.clientX);
          };

          const canvas = canvasRef.current;
          if (canvas) {
            canvas.addEventListener('touchmove', onTouchMove, { passive: false });
            canvas.addEventListener('mousemove', onMouseMove);
          }

          return () => {
            cancelAnimationFrame(animId);
            gameStateRef.current.isPlaying = false;
            if (canvas) {
              canvas.removeEventListener('touchmove', onTouchMove);
              canvas.removeEventListener('mousemove', onMouseMove);
            }
          };
        }, [gameLoop, handleInput]);

        return (
          <div className="relative w-full h-full bg-slate-800 overflow-hidden flex justify-center">
            {/* HUD */}
            <div className="absolute top-4 left-4 z-10 bg-black/40 px-4 py-2 rounded-lg text-white font-mono font-bold border border-white/10 backdrop-blur-sm">
              æ™‚é–“: {uiTime}s
            </div>
            <div className={`absolute top-4 right-4 z-10 px-4 py-2 rounded-lg font-mono font-bold border backdrop-blur-sm transition-colors duration-300 ${
              uiScore >= 200 ? 'bg-yellow-500/80 text-white border-yellow-300' : 'bg-black/40 text-white border-white/10'
            }`}>
              åˆ†æ•¸: {uiScore}
            </div>

            {/* Game Canvas */}
            <canvas
              ref={canvasRef}
              width={CANVAS_WIDTH}
              height={CANVAS_HEIGHT}
              className="h-full w-full max-w-[480px] bg-gradient-to-b from-slate-700 to-slate-900 shadow-2xl cursor-crosshair touch-none"
              onMouseDown={handleShoot}
              onTouchStart={(e) => {
                handleInput(e.touches[0].clientX);
                handleShoot();
              }}
            />
            
            <div className="absolute bottom-4 text-white/30 text-xs pointer-events-none">
              é»æ“Šå°„æ“Š / æ‹–æ›³ç§»å‹•
            </div>
          </div>
        );
      };

      // --- App.tsx ---
      const App = () => {
        const [screen, setScreen] = useState(GameScreen.HOME);
        const [lastScore, setLastScore] = useState(0);

        const startGame = () => {
          setScreen(GameScreen.PLAYING);
        };

        const finishGame = (score) => {
          setLastScore(score);
          setScreen(GameScreen.RESULT);
        };

        const restartGame = () => {
          setScreen(GameScreen.HOME);
        };

        return (
          <div className="h-screen w-screen flex flex-col items-center justify-center bg-gray-900">
            <div className="w-full h-full md:max-w-[480px] md:max-h-[850px] bg-white md:rounded-3xl shadow-2xl overflow-hidden relative">
              {screen === GameScreen.HOME && <Home onStart={startGame} />}
              {screen === GameScreen.PLAYING && <Game onFinish={finishGame} />}
              {screen === GameScreen.RESULT && <Result score={lastScore} onRestart={restartGame} />}
            </div>
          </div>
        );
      };

      // --- index.tsx ---
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>